변수
 - 변수 선언 방법
타입 변수명;
 - 기본 타입 종류와 값
   - 정수형 : int, char
   - 실수형 : double, float
A / B * C / D
A * C / (B*D)
   - 논리형 : boolean
 - 변수명 작성 규칙
   - 숫자로 시작할 수 없다
   - 예약어를 사용할 수 없다
   - 특수문자는 $와 _만 가능
   - 중복 선언이 불가능
   - 대소문자를 구별한다
 - 변수명 작성 관례(일반적으로, 대부분의 개발자들이)
   - 변수명은 소문자로 한다
   - 상수는 대문자로 한다
   - 카멜 표기법 : 변수명이 두단어이상으로 되어 있을 때 두번째 단어부터
     첫글자만 대문자로 표기하는 것
   - 클래스는 첫글자로 대문자로 한다
   - 변수명/메소드/클래스명은 의미있는 단어로 작성

 - 일반변수
   - 기본타입으로 선언한 변수
   - 값을 저장
   - ==로 비교
 - 참조변수
   - 기본타입이 아닌 배열, 클래스, 열거형등으로 선언한 변수
   - 주소를 저장
   - 클래스인경우는 equals() 메소드를 이용 하고, 
     기본타입 배열은 ==로
     클래스 배열은 equals() 메소드로 이용하고,
     열거형은 ==를 이용한다
 - 지역변수
   - 사용하는 지역이 일부(메소드 하나, 반복문 한곳 등)인 경우
 - 멤버변수
   - 클래스의 멤버로, 사용하는 지역이 클래스 안 전체인 경우
     (멤버 변수의 종류에 따라 사용 할 수 없는 메소드가 있을 수 있다)
 - 매개변수
   - 메소드를 동작시키기 위해 알려주는 정보
   - 지역변수
   - 멤버변수와 매개변수의 우선순위는 매개변수가 높다
 - 클래스 멤버 변수
   - static이 붙은 멤버변수
   - 클래스를 통해 호출
 - 객체 멤버 변수
   - static이 안붙은 멤버변수
   - 객체를 통해 호출(대부분 getter를 이용)

- 하나의 변수는 변수 종류 중 한가지에만 속한다(x)

연산자
 - 연산자 종류와 결과
 - 산술연산자
   - +,-,*,/,%
   - 정수 / 정수 => 정수가 되어서 소수점이 사라짐(정확하지 않음)
     타입 변환을 통해 (double)정수 / 정수 => 실수가 되도록 해야 한다
   - % : 나머지를 확인하는 연산자로 말로 표현했을 때 나누었을 때 나머지
     에 해당
   - 산술 연산자의 계산 결과값은 값
 - 대입 연산자
   - =
   - 오른쪽에 있는 값을 왼쪽에 저장
   - 왼쪽에는 변수가 1개 와야 한다
   - 저장, 덮어쓴다, 초기화 등의 표현
   - 대입 연산자는 값 또는 주소값
 - 증감연산자
   - ++, --
   - 최종적으로 1증가/1감소
   - 전위형 : 증가하고 동작
   - 후위형 : 동작하고 증가
   - 증감연산자 결과값은 값
 - 비교연산자
   - >, <, >=, <=, ==, !=
   - 크기 비교
   - 일반변수의 크기를 비교할 때 사용
   - 비교 연산자 결과값은 참 또는 거짓(논리 값)
   - ==와 대입연산자 =을 혼동하지 말자
 - 논리 연산자
   - &&, ||, ! 
   - && : ~하고, ~이고, 둘다 참이면 참, 나머지는 거짓
   - || : ~거나, 둘다 거짓이면 거짓, 나머지는 참
   - ! : ~ 아닌, 반대, 참이면 거짓, 거짓이면 참
   - 논리 연산자 결과값은 참 또는 거짓(논리 값)
 - 조건선택연산자
   - (조건식)?(참) : (거짓)
   - 조건식이 참이면 (참)에 해당하는 부분을 거짓이면 (거짓)에 해당하는
     부분을 실행
 - 조건식 
   - 연산 결과가 참 또는 거짓이 되는 식
 - 연산자 우선 순위
   - 우선순위는 ()가 제일 높다

조건문
 - ~하면 ... 해라
 - ~ : 조건식, ... : 실행문
 - 조문건의 종류 : if문, switch문
 - if문 
   - 모든 조건문을 다룰 수 있다
   - if문 문법
if(조건식1){
	실행문1;
} else if(조건식2){
	실행문2;
} else{
	실행문3;
}
   - if : 무조건 1개
   - else if : 0개 이상
   - else : 0개 또는 1개
   - 위의 문법에서 조건식1과 조건식2를 같이 만족하는 경우에 실행되는
     실행문은? 실행문1이 실행됨
if(조건식1); {
	실행문1;
}
 - switch문
   - 사용하는 변수(식)의 값이 제한적일 때
   - switch문법
switch(변수/식){
case 값1:
	실행문1;
	break;
case 값2:
	실행문2;
	break;
default:	
	실행문3;
}
   - break : switch문을 빠져 나오는 역할
   - switch문에서 break를 만나지 못하면 다음 실행문으로 이동

반복문
 - 규칙적인 작업을 여러번할 때 사용
 - 반복횟수, 규칙성을 찾아야 한다
 - 반복문 종류
   - for문, while문, do while문
 - for문
   - 문법으로 초기화 , 조건식, 증감식을 입력하는 위치가 있다
   - 초기화 : 반복문에서 사용하는 변수를 초기화, 생략 가능
   - 조건식 : 반복문 동작을 결정하는 곳으로 참이면 반복문 동작, 거짓이면
                 반복문 종료, 생략 가능하며 생략하면 항상 참
   - 증감식 : 조건식에서 사용하는 변수를 증가하거나 감소시킨다, 생략가능
   - 초기화, 조건식, 증감식이 반복회수를 결정한다
   - for문 문법
for(초기화 ; 조건식; 증감식){
	실행문;
}
 - while문
   - (강사는) 반복횟수가 정해져 있지 않거나, 순차적으로 증가/감소하지 않는
     경우 while문을 이용
   - while 문법
     - 조건식은 생략 불가능
while(조건식){
	실행문;
}
 - do while문
   - 무조건 한번은 실행
   - ;이 들어 간다
   - do while문 기본 문법
do{
	실행문;
}while(조건식);

- 반복문 사용시 유의 사항
  - 의도치 않은 무한루프가 생기지 않도록 주의
  - 조건식을 잘못 지정해서 실행되지 않는 경우가 생기지 않도록 주의

 - 향상된 for문
   - 배열이나 리스트일 때 향상된 for문을 사용할 수 있다.
   - 배열이나 리스트의 원소들을 전체 탐색할 때 사용
   - 향상된 for문 문법
for(타입 변수명 : 배열이나 리스트){
	실행문;
}

 - break
   - switch문/반복문을 빠져 나가는 역할
   - 반복문에서는 if문과 세트로 같이 나온다
 - contine
   - 스킵
   - for문에서는 증감식위치로 점프(스킵), while문에서는 조건식 위치로 스킵
   - if문과 세트로 같이 나옴
   - continue를 만나면 아래 코드가 있더라도 실행하지 않고 지정된 위치로
     이동

배열
 - (같은 의미) 같은 타입 변수들의 집합
 - 배열은 변수들을 효율적으로 관리하기 위해 사용
 - 배열은 참조변수
 - 배열의 시작번지 0번지부터 크기-1번지까지
 - 배열에서 번지를 잘못사용하면 ArrayIndexOutOfBounds 예외가 발생
 - 배열의 길이는 배열명.length로 알 수 있다
 - 배열은 반복문과 같이 사용 된다

클래스
 - 메소드
   - 하나의 기능을 하도록 모아놓은 코드
   - 매개변수 : 메소드를 실행하기 위해 필요한 정보
   - 리턴타입 : 메소드 실행 후 알려주는 정보
   - 메소드 선언부
리턴타입 메소드명(매개변수){}
   - 리턴값은 해당 메소드를 호출한 메소드에게 알려줌
   - 리턴값이 없는 경우 void를 사용
   - 매개변수는 값 또는 주소값을 복사해서 사용
   - 매개변수가 일반변수인 경우 원래값(메소드를 호출한 곳에서 알려준 값)
     이 변경이 안된다.
   - 매개변수가 참조변수인 경우 원래값이 변경될 수 있다.
   - 메소드 오버로딩
     - 동일한 이름의 메소드가 여러개 존재할 수 있다
     - 매개변수가 다른 경우
       - 매개변수의 갯수가 다른 경우
       - 매개변수의 타입이 다른 경우
 - 멤버변수
   - 클래스에서 나타낼 정보
   - 멤버 메소드에서 멤버변수를 이용하여 동작
   - 멤버변수는 생성자에서 초기화 할 수 있다.
   - 멤버변수가 참조변수이면 객체를 꼭 만들어 놓아야 한다.
      - 명시적 초기화 또는 생성자 또는 초기화 블록
 - 생성자
   - 멤버 변수들을 초기화 하는 곳
   - 일반적으로 접근제한자가 public
   - 이름이 클래스명과 동일
   - 리턴타입을 쓰지 않음
   - new를 이용하여 객체를 생성할 때 호출
   - 객체 생성 후 임의로 호출할 수 없다
   - 생성자 오버로딩을 통해 다양한 형태의 생성자를 만들 수 있다
   - 생성자가 없으면 기본 생성자가 만들어진다
 - 객체 선언 및 생성
클래스명 객체명 = new 클래스명();
 - 객체는 생성을 해야 멤버 메소드와 멤버 변수를 사용할 수 있다
 - 객체를 생성하지 않고 멤버 메소드와 멤버 변수를 사용하면 NullPointer
   예외가 발생한다
 - 멤버 메소드를 호출하는 방법
객체명.메소드명(매개변수);
 - 접근제한자
   - public		: 본인 + 같은 패키지 + 자식 + 다른 패키지
   - protected	: 본인 + 같은 패키지 + 자식
   - 디폴트	: 본인 + 같은 패키지
   - private	: 본인
 - static
   - 멤버 변수/메소드를 클래스 멤버 변수/메소드로 만듬
   - 클래스 변수/메소드는 모든 객체가 공유함
   - 클래스 변수/메소드는 클래스당 1개만 존재
   - static이 안붙은 멤버 변수/메소드를 객체 멤버 변수/메소드라 함
   - 객체 변수/메소드는 각 객체마다 각각 1개씩 존재
   - 클래스 변수는 객체 메소드에서 사용할 수 있다.
   - 객체 변수는 클래스 메소드에서 바로 사용할 수 없다.
   - 클래스 메소드는 객체 메소드에서 사용할 수 있다.
   - 객체 메소드는 클래스 메소드에서 바로 사용할 수 없다.
   - 클래스 변수/메소드는 객체 없이 호출 가능하지만
     객체 변수/메소드는 객체가 있어야 호출이 가능하다
 - final
   - 변할 수 없다
   - 변수    : 상수로 된다
   - 메소드 : 오버라이딩을 할 수 없다
   - 클래스 : 부모클래스가 될 수 없다

상속
 - 부모클래스의 멤버변수/메소드를 물려 받는것
 - extends 키워드를 이용해서 상속
 - 코드의 중복을 제거
 - 쉽게 클래스를 만들기 위해서
 - 서로 다른 자식 클래스들의 개체들을 부모 클래스가 쉽게 관리하기 위해서
 - 클래스 상속에서 부모는 한 클래스만 가능
 - 인터페이스 상속에서 부모는 여러 인터페이스가 가능
 - 메소드 오버라이딩
   - 부모 클래스에 있는 메소드를 자식 클래스에서 재정의 하는 것
   - 부모 클래스의 메소드 선언부가 동일해야한다.(매개변수, 리턴타입이 동일)
   - 접근제한자는 좁은 범위로 줄일 수 없다
     - 부모 클래스 메소드의 접근제한자가 public이면 해당 메소드를 
       자식 클래스에서 오버라이딩 할 때 접근제한자는 public만 가능
       디폴트, protected, private으로 변경 불가능
 - 클래스 타입변환
   - 클래스 타입 변환은 부모와 자식 관계에서 가능
   - 자동 : 자식 클래스의 객체를 부모 클래스의 객체로 변환하는 경우
Parent p = new Child();
   - 강제(조건) : 부모 클래스의 객체를 자식 클래스의 객체로 변환하는 경우
Parent p = new Child();
Child c = (Child)p;

추상클래스
 - Calendar
 - abtract를 붙여줌
 - 추상 클래스는 객체를 생성할 수 없다. 자식 클래스를 이용하여 객체를 생성
 - 추상 메소드
   - 메소드 선언부만 있고, 구현부가 없는 메소드
   - 자식 클래스에서 무조건 오버라이딩을 해야 한다(자식 클래스가 일반
     클래스인 경우)

인터페이스
 - 상수와 추상메소드로 이루어져 있다
 - 인터페이스를 이용하여 객체를 생성할 수 없다
 - 인터페이스를 이용하여 구현 클래스를 만든다. implements를 사용
 - 구현 클래스를 만들 때 여러 인터페이스를 구현해도 된다
 - 구현 클래스에서는 인터페이스에 있는 메소드들을 오버라이딩해야한다
 - 기능 명세서

익명 객체
 - 클래스를 상속받아서(인터페이스를 구현해서) 이름 있는 클래스로 만드는 
   것이 아니라 한 번 사용할 용도로 이름 없는 클래스를 만들어 객체를 
   생성하는 것
 - 익명 객체를 사용하는 경우 새로운 멤버 변수/메소드를 생성하지 않고
   부모 클래스에 있는 메소드나 인터페이스에 있는 메소드를 오버라이딩해서
   사용
A a = new A(){
	//멤버변수와
	//멤버메소드
};

예외처리
 - 프로그램이 중단되는 것 막기 위해
 - 예외 상황을 발견하고 그 상황을 해결하기 위해
 - 예외 : 코드로 해결이 가능한 부분
 - 오류 : 코드로 해결할 수 없는 부분
 - 일반 예외 : 컴파일 단계에서 확인되어 실행되지 않는 예외
 - 실행 예외 : 컴파일 단계에서 확인되지 않고 실행 과정에서 나타는 예외
 - 실행 예외는 예외처리를 하지 않아도 에러가 발생하지 않음.
   일반 예외는 예외처리를 하지 않으면 에러가 발생함
 - 배열 : ArrayIndexOutOfBounds
 - 참조 : NullPointer
 - 나누기 : Arithmetic
 - 타입변환 : ClassCast
 - 문자열을 숫자로 : NumberFormat
 - 예외처리 방법1 : try catch
try{
	예외가 발생할 수 있는 코드;
}catch(예외클래스명1 e){
	예외처리문;
}catch(예외클래스명2 e){
	예외처리문;
}finally{
	실행문;
}
   - 이때 예외클래스명1은 예외클래스명2의 조상클래스이면 안됨
   - finally는 예외처리 과정에서 메소드가 종료되도 무조건 실행 됨
 - 예외처리 방법2 : throws
   - 예외가 발생하면 직접 처리하지 않고 예외를 던져서 남이 처리하게 하는
     방법
   - 메소드 선언부에서 매개변수 옆에 throws 예외클래스명을 입력하여
     발생할 수 있는 예외를 알려줌
   - 단, 실행예외인 경우 throws를 생략할 수 있음
 - 예외 던지기 : throw
   - 자동으로 발생되는 예외가 아닌 변수의 조건에 따라 예외를 발생시키고자
     할때 사용
   - throw는 예외 객체를 던져야하기 때문에 일반적으로
     throw new 예외클래스명("예외메시지"); 형태로 던진다

기본 API클래스
 - Object
   - 모든 클래스의 조상 클래스
   - equals(), toString()
 - String
   - 문자열이 있는지 확인하는 메소드
     - indexOf()
     - contains()
   - 문자열이 같은지 확인하는 메소드 : equals()
   - 구분자를 기준으로 문자열을 추출하여 배열로 만드는 메소드: split()
   - 문자열의 길이를 확인하는 메소드 : length()
 - Math
   - 올림 : ceil()
   - 버림 : floor()
   - 반올림 : round(), rint()
   - 랜덤 : random() 
 - Date
   - 날짜를 문자열로
   - 문자열을 날짜로
 - Calender
   - 달력
   - 년, 월, 일, 시, 분, 초등 다양한 값들을 확인할 수 있다
   - 추상클래스

제네릭 클래스
 - 클래스의 멤버 변수 또는 메소드의 타입이 객체를 선언할 때 결정되는 
   클래스
 - <>로 클래스명이 필요하다. 생략하면 <Object>를 한거와 같다.

컬렉션 프레임워크
 - 인터페이스 : List, Set, Map
 - 데이터를 쉽게 관리하기 위해 만들어 놓은 인터페이스
 - List
   - 순서 보장, 중복가능
   - 구현 클래스 : ArrayList, LinkedList
   - 멤버 메소드
   - 향상된 for문을 이용할 수 있다
   - Iterator를 이용하여 값들을 가져올 수 있다.
 - Set
   - 중복 불가능, 순서 보장 x
   - 구현 클래스 : HashSet
   - 멤버 메소드
   - Iterator를 이용하여 반복문을 사용해야 값들을 가져올 수 있다
     List에 있는 get()메소드가 없기 때문에 Iterator를 이용하지 않고는
     값을 확인할 수 없다
 - Map
   - 두 종류의 데이터를 저장, key와 value
   - key는 중복 불가능
   - value는 중복 가능
   - 순서를 보장하지 않음
   - 이미 있는 key값에 중복으로 데이터를 넣으면 최신 데이터로 덮어쓴다
   - 값들을 확인하기 위해 Set으로 변환시켜야 된다
     - key값들을 Set으로 만들어서 확인
     - Entry라는 클래스를 이용하여 Set으로 만들어서 확인












