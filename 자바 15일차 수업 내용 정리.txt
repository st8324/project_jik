추상 클래스
 - 공통된 멤버변수(필드)와 메소드의 이름을 통일하려고 사용
   => 시간을 절약
abstract class 클래스명{

}
 - 추상 클래스를 이용하여 객체를 생성할 수 없다
   => 추상 클래스를 상속한 자식 클래스를 만든후 객체를 생성해야 한다
 - 추상 클래스는 추상 메소드를 생성할 수 있다
 - 추상 메소드는 선언부만 있고 구현부가 없는 메소드
   => 기능명은 있지만 구현되지 않음
 - 추상 클래스에 추상 메소드가 있으면 추상 클래스를 상속받은 자식 클래스에서
   (자식 클래스가 일반 클래스인 경우)추상 메소드를 무조건 오버라딩해야 한다
   => 구현부가 없기 때문에 구현해줘야 한다
 - 추상 메소드가 있으면 일반 클래스가 될 수 없고 추상 클래스이어야 한다.

인터페이스 (기능 명세)
- 메소드는 추상 메소드만 있을 수 있다
  => abstract라는 키워드가 없어도 자동으로 추가 됨
- 변수는 있을 수 없고 상수(클래스 상수)만 있을 수 있다
  => static final이라는 키워드가 없어도 자동으로 추가 됨
- 매개변수의 다형성을 인터페이스를 이용해서도 적용할 수 있다.
- 인터페이스를 이용하여 객체를 만들 수 없다
- 인터페이스는 구현 클래스를 생성한 후 객체를 만들 수 있다.
- 상속은 extends, 구현은 implements를 이용
- 구현클래스는 여러개의 인터페이스를 구현할 수 있다.



- 매개변수의 다형성
  - 메소드의 매개변수를 부모클래스로 설정하면, 해당 부모 클래스를 상속받은
    자식 클래스들이 매개변수로 올 수 있다
  
추상 클래스		vs	인터페이스
- 객체변수, 객체상수			- 클래스 상수, 추상 메소드
  클래스변수, 클래스 상수
  객체메소드, 클래스메소드, 
  추상 메소드		



타입변환
- 상속
  1. 자동
     자식클래스 객체1 = new 자식클래스();
     부모클래스 객체2 = 객체1;
  2. 강제
     부모클래스 객체3 = new 자식클래스();
     자식클래스 객체4 = (자식클래스)객체3

- 구현
  1. 자동
     구현클래스 객체5 = new 구현클래스();
     인터페이스 객체6 = 객체5;
  2. 강제
     인터페이스 객체7 = new 구현클래스();
     구현클래스 객체8 = (구현클래스)객체7;


인터페이스의 상속
- 클래스의 상속과는 다르게, 
   인터페이스의 상속은 다중 상속이 가능



















