클래스 상속
 - 부모클래스의 멤버변수/메소드를 자식 클래스가 물려받는것
 - 부모클래스 모든 멤버변수/메소드를 물려 받을 수 있다(x)
   => 접근제한자가 private이면 물려받을수 없다
 - 부모 클래스의 멤버변수/메소드를 선언하지 않아도 사용할 수 있다
 - 자식 클래스가 A, 부모클래스 B
class A extends B{

}
 - A는 B이다가 성립하면 상속이 가능 : is a 관례
 - 모든 클래스는 부모 클래스의 생성자를 호출한다.
 - super()를 통해 직접 호출하지 않으면 부모클래스의 기본생성자를 자동으로 호출한다
 - 부모클래스는 하나만 존재 => 부모가 존재할 수 있고, 조부모가 존재할 수 있지만
   부모가 2분씩 있을 수 없다

메소드 재정의(메소드 오버라이드/오버라이딩)
 - 부모클래스의 메소드를 자식 클래스가 재정의 하는 것
 - 부모클래스의 메소드와 선언이 똑같은 메소드를 입력하고 구현부를 수정

final : 수정할 수 없는
 - 변수 : 상수
 - 메소드 : 오버라이딩 불가능 => 자식클래스에서 해당 메소드를 재정의 할 수 없다
 - 클래스 : 상속할 수 없다 => 해당 클래스는 부모클래스가 될 수 없다

class A{}
class AA extends A{}
class AAA extends AA{}

class B{
	public int num;
	public void print(){
		System.out.println("안녕");
	}
}
class C{
	public int num;
	public void print(){
		System.out.println("Hi");
	}
}
class BC extends B, C{} //에러 발생

class D{
	public void print(){}
	public void print(int num){}
	public void print(){
		int num = 0;
	}
}

클래스간 타입 변환(p.333)
- 자동으로 가능한 경우
  - 자식클래스의 객체를 부모클래스로 변환시키는 경우 자동으로 가능
자식클래스 객체1 = new 자식클래스();
부모클래스 객체2 = 객체1;
- 명시적으로 가능한 경우
  - 부모 클래스의 객체를 자식클래스로 변환시키는 경우 명시적(강제)으로 해야하는데
    항상 가능한건 아니다
    - 부모 객체가 자식 클래스로 만들어진 경우 자식 클래스로 변환시키는 경우 가능
P p = new C();
C c = (C)p;
    - 부모 객체가 부모 클래스로 만들어진 경우 자식 클래스로 변환시킬수 없다
P p = new P();
C c = (C)p;

A instanceof  B
- A를 B로 타입변환 할수 있는지를 확인, 할수 있으면 결과값이 true,
  없으면 결과값이 false

상속
 - A는 B이다
멤버변수
 - A는 B를 가지고 있다

스마트폰은 카메라이다(x) => 카메라를 스마트폰에 상속할 수가 없다
스마트폰은 카메라를 가지고 있다(o) => 카메라는 스마트폰의 멤버변수 될 수 있다

가계부는 내역이다(x)
가계부는 내역들을 가지고 있다(O) => 멤버변수























