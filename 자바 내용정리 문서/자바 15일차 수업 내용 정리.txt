추상 클래스
 - 공통된 멤버변수(필드)와 메소드의 이름을 통일하려고 사용
   => 시간을 절약
abstract class 클래스명{

}
 - 추상 클래스를 이용하여 객체를 생성할 수 없다
   => 추상 클래스를 상속한 자식 클래스를 만든후 객체를 생성해야 한다
 - 추상 클래스는 추상 메소드를 생성할 수 있다
 - 추상 메소드는 선언부만 있고 구현부가 없는 메소드
   => 기능명은 있지만 구현되지 않음
 - 추상 클래스에 추상 메소드가 있으면 추상 클래스를 상속받은 자식 클래스에서
   (자식 클래스가 일반 클래스인 경우)추상 메소드를 무조건 오버라딩해야 한다
   => 구현부가 없기 때문에 구현해줘야 한다
 - 추상 메소드가 있으면 일반 클래스가 될 수 없고 추상 클래스이어야 한다.

인터페이스 (기능 명세)
- 메소드는 추상 메소드만 있을 수 있다
  => abstract라는 키워드가 없어도 자동으로 추가 됨
- 변수는 있을 수 없고 상수(클래스 상수)만 있을 수 있다
  => static final이라는 키워드가 없어도 자동으로 추가 됨
- 매개변수의 다형성을 인터페이스를 이용해서도 적용할 수 있다.
- 인터페이스를 이용하여 객체를 만들 수 없다
- 인터페이스는 구현 클래스를 생성한 후 객체를 만들 수 있다.
- 상속은 extends, 구현은 implements를 이용
- 구현클래스는 여러개의 인터페이스를 구현할 수 있다.



- 매개변수의 다형성
  - 메소드의 매개변수를 부모클래스로 설정하면, 해당 부모 클래스를 상속받은
    자식 클래스들이 매개변수로 올 수 있다
  
추상 클래스		vs	인터페이스
- 객체변수, 객체상수			- 클래스 상수, 추상 메소드
  클래스변수, 클래스 상수
  객체메소드, 클래스메소드, 
  추상 메소드		



타입변환
- 상속
  1. 자동
     자식클래스 객체1 = new 자식클래스();
     부모클래스 객체2 = 객체1;
  2. 강제
     부모클래스 객체3 = new 자식클래스();
     자식클래스 객체4 = (자식클래스)객체3

- 구현
  1. 자동
     구현클래스 객체5 = new 구현클래스();
     인터페이스 객체6 = 객체5;
  2. 강제
     인터페이스 객체7 = new 구현클래스();
     구현클래스 객체8 = (구현클래스)객체7;


인터페이스의 상속
- 클래스의 상속과는 다르게, 
   인터페이스의 상속은 다중 상속이 가능

		일반클래스	추상클래스	인터페이스
멤버변수		O		O		X
상수		O		O		O
메소드		O		O		X
추상메소드	X		O		O
객체생성		O		X(자식클래스생성)	X(구현클래스생성)
상속갯수		1		1		여러개


class A{

}

class B{

}
 - 중첩 클래스 : 클래스 안에 클래스가 선언되어 있는 형태
   - A클래스를 구현할 때 B 클래스가 필요하지만, 다른 클래스에서는 B클래스가
     쓸모 없는 경우 중첩 클래스를 이용
class A{
	class B{

	}
}

익명 객체
- 일반적으로 클래스를 생성하고, 생성한 클래스를 이용하여 객체를 만듬
  => 객체의 이름이 있다
1. 자식 클래스 대신 익명 객체 사용
  - 자식 클래스가 재사용 되지 않고 딱 한군데에서 사용되는 경우 자식 클래스를
    만드는 대신 익명 객체를 만들어서 사용
2. 구현 클래스 대신 익명 객체 사용(제공되는 라이브러리를 이용해서 많이 사용)
  - 구현 클래스가 재사용 되자 않고 딱 한군데에서만 사용되는 경우 구현 클래스를
    마드는 대신 익명 객체를 만들어서 가용
- 익명 객체는 재사용이 안될 때 사용하는 방법. 재사용이 많이 되는 경우는
  사용을 피하자.
- 익명 객체가 어려우면 굳이 사용않해도 대체방법이 있다.
  => 자식클래스를 생성하거나 구형 클래스를 생성하면 된다.
- 익명 객체를 몰라도 된다. 단 메소드안에서 @Override를 본다면 익명
  객체를 이용했구나 정도만 떠올리면 된다.
  => 메소드안에서 메소드가 구현됐는데 에러가 안난다면 익명객체를 이용한
       것이다.

예외처리 : 예외를 처리
- 예외 : 코드로 해결이 가능한 것
- 오류 : 코드로 해결이 불가능한 것
- 모든 예외 클래스의 조상은 Exception 클래스 
- 일반예외 : 컴파일 과정에서 오류가 남. 실행되지 않음
- 실행예외 : 실행되는 과정에서 오류가 남. 일단 실행은 됨
- 예외가 발생되었을 때 예외처리가 안되어 있다면 프로그램이 중단됨.
  프로그램이 중단되는걸 막기 위해 예외처리를 해야한다.
- 예외처리란 예외를 사전에 방지하는 아니라 예외가 발생했을 때 프로그램이 중단
  되는것을 막는것을 의미함

실행예외의 종류
1. NullPointerExeption  
  - 참조변수를 이용하는 경우 발생할 수 있다. 참조변수는 null로 초기화가 가능하기
    때문에
  - 객체나 배열을 생성하지 않고 멤버변수나 메소드를 사용하는 경우 발생
  - 해결 방법(예외가 발생하지 않도록 사전에 처리하는 방법)
    - 객체나 배열을 생성
    - 멤버변수나 메소드를 호출하기전에 조건문을 이용하여 null인지 체크를 하면 된다

2. ArrayIndexOutOfBounsException
  - 배열을 이용할 때 발생할 수 있다
  - 잘못된 배열 번지에 접근하는 경우 발생한다
  - 해결방법
    - 배열의 번지는 0부터 arr.length보다 작다는 걸 기억하자
    - 향상된 for문을 이용해도 되는 상황이면 적극적으로 이용하자

3. NumberFormatException
  - 문자열을 숫자로 변환할때에 발생할 수 있다.
  - 문자열에 숫자가 아닌 문자들이 있는 경우 발생한다.

4. ClassCastExeption
  - 클래스 타입변환시 발생할 수 있다.
  - 해결방법
    - 조건문과 instanceof를 이용하자



















