자바 : 객체지향 프로그래밍 언어(oop)

전화를 걸어야한다.
절차			vs	객체
전화거는 기능을 만들어서		전화를 걸수 있는 기능을 가진 핸드폰을
전화를 건다.			설계한다 => 클래스
				설계도를 통해 핸드폰을 만든다
				=> 객체 생성
				핸드폰으로 전화를 건다
				=> 객체의 메소드 호출

클래스 
 - 멤버변수 : 정보
 - 멤버메소드 : 기능
 - 생성자 : 정보의 초기값 설정

멤버변수
 - 객체는 멤버변수가 될 수 없다(x) => 객체는 멤버 변수가 될 수 있다.
 - 멤버변수는 생성자에서 사용가능하다(o)
   멤버변수는 멤버메소드에서 사용가능하다(o)
   => 멤버 변수는 클래스내에서 사용가능하다
        단, 객체변수냐 클래스 변수냐에 따라 불가능 할 수도 있다
 - 일반적으로 접근제한자를 private으로 한다.
    => getter와 setter가 필요하다 => 이클립스에서 클릭으로  생성 가능

멤버 메소드
 - 기능, 매개변수, 리턴타입을 정리한 후 메소드를 선언하고, 구현한다.
 - 오버로딩
   - 동일한 이름을 가진 메소드가 여러개 있는 경우
   - 매개변수가 다를 때

생성자
 - 멤버변수를 초기화 하는 곳
 - new 연산자를 통해서 객체를 생성한 후 호출이 된다.
   => 객체.생성자()로 호출할 수 없다.
   => 마음대로 부를 수 없다.
 - 이름이 클래스와 같다
 - 오버로딩
   - 생성자가 여러개 있는 경우
   - 매개변수가 다를 때
 - this()를 이용하여 다른 생성자를 호출할 수 있다
 - 클래스에 생성자가 하나도 없을 때, 기본 생성자가 자동으로 만들어진다.
 - 클래스에 생성자가 하나라도 있을 때 기본 생성자가 만들어지지 않는다.

클래스 변수/메소드			객체 변수/메소드
- 클래스가 메모리에 올랐을 때 생성	- 객체를 생성할 때 생성
- 객체 생성 없이 호출이 가능		- 객체를 꼭 생성해야 호출 가능
- static이 붙음			- static이 안붙음
- 클래스 변수는 모든 객체가 공유	- 객체 변수는 각 객체마다 변수가 존재
  => 객체가 n개라면 클래스 변수는   	   => 객체가 n개라면 객체 변수는 n개
       1개


- 클래스 메소드를 객체 메소드에서 호출할 수 있다(O)
  => 클래스 메소드는 객체를 생성하기 전에 만들어진다.
       객체를 생성하고 나서 호출되는 객체 메소드에서 클래스 메소드를 호출할 수 있다
- 클래스 변수를 객체 메소드에서 호출할 수 있다(O) 
- 객체 메소드를 클래스 메소드에서 호출할 수 있다(X)
- 객체 변수를 클래스 메소드에서 호출할 수 있다(X) 
- 클래스 변수를 클래스 메소드에서 호출할 수 있다(O)
- 객체 변수를 객체 메소드에서 호출할 수 있다(O)


final : 바꿀수 없는
- 변수 : 상수
- 메소드 : 오버라이딩 불가능
- 클래스 : 상속할 수 없음


클래스 상속 : 부모 클래스의 멤버 변수/메소드를 물려 받는 것
 - 접근제한자가 private이면 물려받지 못함
   =>부모 클래스에 해당 변수에 대한 getter와 setter를 만들어서 자식 클래스에서 사용
 - 접근제한자가 디폴트이면 같은 패키지가 아닌 경우 물려받지 못함
 - 접근제한자가 public, protected이면 물려 받음

class 자식클래스명 extends 부모클래스명{

}
 - 코드의 중복을 제거할 수 있다
 - 부모클래스에 구현된 메소드를 사용할 수 있기 때문에 효율이 좋다

상속을 할 수 있는 경우
- A는 B이다가 성립하면 상속을 할 수 있다.
  - A : 자식 클래스, B는 부모클래스
- 사람은 동물이다(O) => 동물 클래스를 상속받아 사람 클래스를 만들 수 있다
- 동물은 사람이다(X) => 사람 클래스를 상복받아 동물 클래스로 만들수 없다
- 스마트폰은 폰이다(O)
  - 스마트폰 : 자식
  - 폰 : 부모
- 스마트폰은 카메라이다(X)
- 사각형은 도형이다(O)
- 삼각형은 도형이다(O)
- 원은 도형이다(O)
  - 부모 : 도형
  - 자식 : 사각형, 삼각형, 원

상속받은 자식클래스의 생성자
- 자식클래스의 생성자를 호출하면 자식 클래스의 생성자가 실행되는데, 자식 클래스
  생성자 안에 부모생성자가 있어서 먼저 호출이 된다.
- 자식클래스의 생성자안에 부모클래스의 생성자가 없으면 부모클래스의 기본 생성자
  가 자동으로 호출 됨
- 부모 클래스의 생성자는 super()를 통해 호출
- 부모 클래스의 생성자를 호출하려면 super()위에 코드가 없어야한다
- 부모 클래스의 생성자를 super()를 통해 호출하면 본인 클래스의 생성자 this()를 
   이용할 수 없다

super				vs	this
- 부모 클래스의 객체를 의미			- 내 클래스의 객체를 의미
- 생성자 : super()				- 생성자 : this()
- 멤버 호출				- 멤버 호출
  super.멤버변수				  this.멤버변수
  super.멤버메소드()				  this.멤버메소드()
  - 단 접근제한자에 따라 부모 클래스의		- 접근 제한자 상관없이 호출 가능
    메소드를 호출할 수 없을 수 있다.

























